%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>

using namespace std;

extern "C" int yylex();
extern int yylineno;

void yyerror (char const *error);
void error_custom_line(char const *error, int line);
void warning_custom_line(char *warning, int line);

char* RED = "\033[0;31m";
char* ORANGE = "\033[0;33m";
char* GREEN = "\033[0;32m";
char* WHITE = "\033[0m";
%}
%code requires {
    struct GenericInfo{
		char* string;
		int starting_line;
	};

	struct XmlTagInfo{
		struct GenericInfo* opening_tag;
		struct GenericInfo* closing_tag;
	};
};

%union{
	struct GenericInfo* generic_info;
	struct XmlTagInfo* xml_tag_info;
	int linenumber;
}

%define parse.error verbose

%token <generic_info> OPENING_TAG
%token <generic_info> CLOSING_TAG
%token <generic_info> SELF_CLOSING_TAG
%token <generic_info> TEXT_FRAGMENT

%token <linenumber> XML_DECLARATION
%token YYEOF

%type <linenumber> header
%type <xml_tag_info> xml_element
%type <generic_info> text

/* Info of xml_element_list is the info of the last xml_element matched */
%type <xml_tag_info> xml_element_list

%start S

%%

S : header body YYEOF{
		if($1 != 1){
			error_custom_line("XML declaration must be at first line",1);
		}
		printf("%svalid XML syntax%s\n", GREEN, WHITE);
	}
	| body YYEOF{
		// Esta es la manera buena de hacerlo?
		error_custom_line("XML file is missing header",1);
	}
	| body header{
		error_custom_line("found XML declaration after root tag. XML declaration must be at the first line",$2);
	}
	| header YYEOF{
		// Esta es la manera buena de hacerlo?
		yyerror("XML file is missing body");
	}
	| header header{
		error_custom_line("there can be only one header",$2);
	}
	| header body header {
		error_custom_line("there can be only one header, and it must be located at line 1",$3);
	}
	| YYEOF{
		error_custom_line("XML file is empty",1);
	}


header : XML_DECLARATION;

body : xml_element
	| xml_element xml_element{
		char error[512];

		struct GenericInfo* opening_tag = $2->opening_tag;
		struct GenericInfo* closing_tag = $2->closing_tag;


		sprintf(error,"there can be only one root tag. Found a second one with "
		"opening tag <%s> declared at line %d and closing tag <%s> declared at line %d",
		opening_tag->string,opening_tag->starting_line,closing_tag->string,closing_tag->starting_line);

		error_custom_line(error,opening_tag->starting_line);
	}
	| xml_element CLOSING_TAG{
		char error[512];
		sprintf(error,"found closing tag </%s> declared at line %d without a corresponding opening tag",
		$2->string,$2->starting_line);
		error_custom_line(error,$2->starting_line);
	}
	| CLOSING_TAG{
		char error[512];
		sprintf(error,"root closing tag </%s> is missing opening tag",$1->string);
		yyerror(error);
	}
	| text {
		char error[512];
		sprintf(error,"found text before root tag. Text must be inside a XML tag");
		error_custom_line(error,$1->starting_line);
	}
	| xml_element text {
		char error[512];
		sprintf(error,"found text after root tag. Text must be inside a XML tag");
		error_custom_line(error,$2->starting_line);
	}

		 	


xml_element : SELF_CLOSING_TAG{
				struct XmlTagInfo *xml_tag_info = (XmlTagInfo*) malloc(sizeof(struct XmlTagInfo));
				xml_tag_info->opening_tag = $1;
				xml_tag_info->closing_tag = $1;
				$$ = xml_tag_info;
			}
			| OPENING_TAG element CLOSING_TAG {
				char error[512];
				if (strcmp($1->string,$3->string)!=0) {
					sprintf(error, "opening and closing tags do not match"
					", declared <%s> at line %d and expected </%s> at line %d, but got </%s> instead", 
					$1->string,$1->starting_line,$1->string,$3->starting_line,$3->string);
					yyerror(error);
				}
				struct XmlTagInfo *xml_tag_info = (XmlTagInfo*) malloc(sizeof(struct XmlTagInfo));
				xml_tag_info->opening_tag = $1;
				xml_tag_info->closing_tag = $3;
				$$ = xml_tag_info;
				}

			| OPENING_TAG element YYEOF{
				char error[512];
				sprintf(error, "unexpected end of file. Expected closing tag for <%s>, declared at line %d", $1->string,$1->starting_line);
				yyerror(error);}
		 	
			

element : | text  | xml_element_list 
		  | mixed_text_xml_element

mixed_text_xml_element : 
			  text xml_element element{
				// In this rule we have to match to `xml_element` instead of `xml_element_list`, since `element` is generated by also a `xml_element_list`
				// But the warning works well if a `xml_element_list` comes after `text` (multiple `TEXT_FRAGMENTS`)
				char warning[512];
				struct GenericInfo* opening_tag = $2->opening_tag;
				sprintf(warning,"found XML element <%s> (declared at line %d) after text (declared at line %d). Inside an XML tag "
					"it is not recommended to mix text and xml tags",opening_tag->string,opening_tag->starting_line,$1->starting_line);
				warning_custom_line(warning,opening_tag->starting_line);
			}
			| xml_element_list TEXT_FRAGMENT element{
				// In this rule we have to match to `TEXT_FRAGMENT` instead of `text`, since `element` is generated by also a `text`
				// But the warning works well if a `text` (multiple `TEXT_FRAGMENTS`) comes after `xml_element_list`
				char warning[512];
				struct GenericInfo* opening_tag = $1->opening_tag;
				sprintf(warning,"found text (declared at line %d) after XML element <%s> (declared at line %d). Inside an XML tag "
					"it is not recommended to mix text and xml tags",$2->starting_line,opening_tag->string,opening_tag->starting_line);
				warning_custom_line(warning,$2->starting_line);
			}





text: TEXT_FRAGMENT {
		// Keep track of the info of first TEXT_FRAGMENT in the text 
		$$ = $1;
	}
	| text TEXT_FRAGMENT{
		$$ = $1;
	};

xml_element_list : xml_element{
					// Keep track of the info of last xml_element of the list
					$$ = $1;
				}
				| xml_element xml_element_list{
					// Keep track of the info of last xml_element of the list
					$$ = $2;
				 };


%%
int main(int argc, char *argv[]) {
extern FILE *yyin;

	switch (argc) {
		case 1:	
			yyin=stdin;
			yyparse();
			break;
		case 2: 
			yyin = fopen(argv[1], "r");
			if (yyin == NULL) {
				printf("ERROR: Could not open file\n");
			}
			else {
				yyparse();
				fclose(yyin);
			}
			break;
		default: printf("ERROR: too many arguments.\nSyntax: %s [input_file]\n\n", argv[0]);
	}

	return 0;
}
void yyerror (char const *error) {
	error_custom_line(error, yylineno);
}

void error_custom_line(char const *error, int line) {
	/* Some errors need to use line number on the last line scanned (TEXT XML_ELEMENT tokens),
	and others just need the starting line of the expression (starting_lineno)*/
	char buf[512];
	sprintf(buf,"%ssyntax error at line %d:%s %s", RED, line, WHITE, error);
	fprintf (stderr, "%s\n", buf);
	fprintf (stderr, "%sinvalid XML syntax%s\n", RED, WHITE);
	
	exit(1);
}
void warning_custom_line(char *warning, int line) {
	char buf[512];
	sprintf(buf,"%swarning at line %d:%s %s", ORANGE, line, WHITE, warning);
	fprintf (stderr, "%s\n", buf);
}


